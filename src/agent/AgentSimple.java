package agent;

import java.util.ArrayList;
import java.util.List;

import control.Constants;
import control.SeededRandom;
import landscape.FitnessFunction;
import landscape.NKLandscape;

/**
 * The Agent class represents the agents that navigate the landscape. They use
 * their developmental program and blocks to construct their developmental strategy,
 * then execute their developmental strategy by incrementally making changes to their
 * phenotype.
 * 
 * This implementation uses the NKPhenotype for use on NK landscapes.
 * 
 * @author Jacob Ashworth
 *
 */
public class AgentSimple implements Comparable<AgentSimple> {
	
	//These fields are generated by compileStrategy()
	private List<Step> strategy;
	/* This integer tracks the next step to run, so currentStep=0 means
	 * step 0 has not yet been executed. */
	private int currentStep = 0;
	 
	//Fields related to phenotype.
	public Phenotype phenotype;
	/* phenotypeHistory is indexed by step number, so phenotypeHistory.get(4)
	 * would give you the phenotype immediately before step 4 was executed */
	private List<Phenotype> phenotypeHistory;
	
	//Fields related to fitness
	private FitnessFunction fitnessFunction;
	private double fitness;
	//fitnessHistory is indexed the same as phenotypeHistory
	private List<Double> fitnessHistory;
	
	/**
	 * Constructor used to exactly specify an agent, with all relevant fields. 
	 * Mostly called by the identicalChild() function.
	 */
	public AgentSimple(FitnessFunction fitnessFunction, Phenotype phenotype, List<Step> strategy)
	{
		this.strategy = strategy;
		this.phenotype = phenotype;
		this.fitnessFunction = fitnessFunction;
		this.fitness = fitnessFunction.getFitness(phenotype);
		//Compile the program and blocks into the strategy
		this.initializeHistory();
	}
	
	public static Phenotype getRandomPhenotype() {
		switch(Constants.PHENOTYPE_TYPE.toLowerCase()) {
			case "nkphenotype":
				return new Bitstring();
			default:
				System.out.println("PHENOTYPE_TYPE not recognized");
				return null;
		}
	}
	
	/**
	 * This method compiles the developmental strategy from the program and
	 * the blocks by concatenating copies of the blocks specified in the order
	 * of the program
	 */
	private void initializeHistory()
	{
		this.phenotypeHistory = new ArrayList<Phenotype>();
		this.phenotypeHistory.add(phenotype);
		this.fitnessHistory = new ArrayList<Double>();
		this.fitness = fitnessFunction.getFitness(phenotype); 
		this.fitnessHistory.add(fitness);
	}
	
	/**
	 * Method to check if the agent has executed all steps in its developmental strategy
	 * @return
	 */
	public boolean agentDeveloped()
	{
		return currentStep == strategy.size();
	}
	
	/**
	 * Executes the current step of the developmental strategy
	 */
	public void executeSingleStep()
	{
		//Get the step to execute and increment step counter
		Step stepToExecute = strategy.get(currentStep);
		currentStep++;
		
		//This is the main switch statement that controls which step is executed
		//When adding new steps, create a new step function and enum in Step, and add
		//it to the switch statement.
		switch(stepToExecute) {
			case RandomWalk:
				randomWalk();
				break;
			case SteepestClimb:
				steepestClimb();
				break;
			case SteepestFall:
				steepestFall();
				break;
		}
		
		//update the agent's fitness value
		fitness = fitnessFunction.getFitness(phenotype);
		
		//Store information
		phenotypeHistory.add(phenotype);
		fitnessHistory.add(fitness);
	}
	
	/**
	 * Executes the entire developmental strategy
	 * 
	 * If strategyExecutionSampleSize>1, this method will
	 * execute the entire strategy many times, but will delete
	 * the contents of pastPhenotypes since tracking past phenotype
	 * with a sample size greater than 1 isn't helpful
	 */
	public void executeStrategy()
	{
		while(!agentDeveloped())
		{
			executeSingleStep();
		}
	}
	
	/**
	 * Compares fitness for sorting
	 */
	@Override
	public int compareTo(AgentSimple other) {
		if(this.fitness > other.fitness)
		{
			return 1;
		}
		else if(this.fitness == other.fitness)
		{
			return 0;
		}
		else
		{
			return -1;
		}
	}
	
	//-------------------------------------------------------------------------------------------------------------------
	/**
	 * This area is for the different types of steps in the developmental program. These
	 * steps are called during the execution of executeSingleStep or executeStrategy.
	 * 
	 * These steps are only responsible for updating the value in phenotype. Saving previous
	 * phenotypes and updating the fitness is the responsibility of executeSingleStep
	 */
	
	/**
	 * Chooses a random neighbor of the current phenotype to be the new phenotype
	 */
	private void randomWalk()
	{
		List<Phenotype> neighbors = phenotype.getNeighbors();
		phenotype = neighbors.get(SeededRandom.getInstance().nextInt(neighbors.size()));
	}
	
	/**
	 * Chooses the highest fitness neighbor to be the new phenotype
	 */
	private void steepestClimb()
	{
		List<Phenotype> neighbors = phenotype.getNeighbors();
		Phenotype bestNeighbor = neighbors.get(0);
		for(Phenotype neighbor : neighbors)
		{
			if(fitnessFunction.getFitness(neighbor) > fitnessFunction.getFitness(bestNeighbor))
			{
				bestNeighbor = neighbor;
			}
		}
		phenotype = bestNeighbor;
	}
	
	/**
	 * Chooses the lowest fitness neighbor to be the new phenotype
	 */
	private void steepestFall()
	{
		List<Phenotype> neighbors = phenotype.getNeighbors();
		Phenotype worstNeighbor = neighbors.get(0);
		for(Phenotype neighbor : neighbors)
		{
			if(fitnessFunction.getFitness(neighbor) < fitnessFunction.getFitness(worstNeighbor))
			{
				worstNeighbor = neighbor;
			}
		}
		phenotype = worstNeighbor;
	}
	//-------------------------------------------------------------------------------------------------------------------

	public List<Double> getFitnessHistory() {
		return fitnessHistory;
	}
	
	public List<Step> getStrategy() {
		return strategy;
	}
	
	public List<Phenotype> getPhenotypeHistory(){
		return phenotypeHistory;
	}
	
	/**
	 * Returns the fitness of the agent if it is developed, otherwise it prints an error and returns -1.
	 * @return
	 */
	public double getFinalFitness() {
		if(agentDeveloped())
		{
			return fitness;
		}
		else
		{
			System.out.println("getFinalFitness called on undeveloped agent");
			return -1;
		}
	}
	
	/**
	 * Returns the phenotype of the agent if it is developed, otherwise it prints an error and returns null.
	 * @return
	 */
	public Phenotype getFinalPhenotype() {
		if(agentDeveloped())
		{
			return phenotype;
		}
		else
		{
			System.out.println("getFinalFitness called on undeveloped agent");
			return null;
		}
	}
}
